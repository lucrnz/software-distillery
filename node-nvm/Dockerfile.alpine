ARG ALPINE_VERSION=3.22
ARG NVM_VERSION=0.40.3
ARG NODE_VERSION=24.11.1
ARG YARN_VERSION=1.22.22

FROM ghcr.io/lucrnz/ripvex:dev-20251209-c34d36e AS ripvex

# Base downloader image used to perform any secure download.
FROM alpine:latest AS nvm-download
COPY --from=ripvex /ripvex /usr/local/bin/ripvex
COPY --from=ripvex /etc/ssl/certs/ca-certificates.crt /etc/ssl/certs/ca-certificates.crt
RUN apk add --no-cache ca-certificates bash

# NVM doesn't work with the 'set -u' flag
SHELL ["/bin/bash", "-exo", "pipefail", "-c"]

ARG NVM_VERSION
ENV NVM_DIR=/opt/nvm

RUN mkdir -p $NVM_DIR && \
  SCRIPT_F="/tmp/nvm-install.sh" && \
  NVM_URL="https://raw.githubusercontent.com/nvm-sh/nvm/v$NVM_VERSION/install.sh" && \
  ripvex --url="$NVM_URL" --output="$SCRIPT_F" && \
  chmod +x $SCRIPT_F && \
  bash $SCRIPT_F && \
  rm -f $SCRIPT_F

# NVM builder
FROM alpine:${ALPINE_VERSION} AS builder

RUN apk add --no-cache ca-certificates openssl ncurses coreutils \
  make gcc g++ libgcc linux-headers grep util-linux binutils findutils \
  musl-dev \
  libstdc++ curl bash wget git libbz2 zlib xz-libs readline sqlite-libs \
  gdbm expat libffi libnsl

SHELL ["/bin/bash", "-exo", "pipefail", "-c"]

ARG ALPINE_VERSION
ARG NODE_VERSION
ARG YARN_VERSION
ENV NVM_DIR=/opt/nvm
ENV PYENV_ROOT=/opt/pyenv

COPY --from=nvm-download /opt/nvm /opt/nvm
COPY --from=ripvex /ripvex /usr/local/bin/ripvex
COPY --from=ripvex /etc/ssl/certs/ca-certificates.crt /etc/ssl/certs/ca-certificates.crt

WORKDIR /root

# Install python-3.13.11-pyenv from software-distillery release
RUN ARCH=$(uname -m) && \
  if [ "$ARCH" = "x86_64" ]; then \
    ARCH="amd64"; \
  fi && \
  PYENV_VERSION="2.6.16" && \
  RELEASE_TAG="released-20251209-1917" && \
  PYENV_URL="https://github.com/lucrnz/software-distillery/releases/download/${RELEASE_TAG}/testbuild_donotuseinproduction_python-3.13.11-pyenv-${PYENV_VERSION}-alpine-${ALPINE_VERSION}-${RELEASE_TAG}-${ARCH}.tar.gz" && \
  mkdir -p /opt/pyenv && \
  cd /opt/pyenv && \
  ripvex --url="$PYENV_URL" --extract-archive --extract-strip-components=2 && \
  . env.sh && \
  python --version && \
  cd /root

RUN apk update && \
  CLANG_BIN="clang-19" && \
  CXX_BIN="clang++-19" && \
  if apk info clang19 > /dev/null 2>&1; then \
    apk add --no-cache clang19; \
    echo "Using Clang-19 from Alpine repos"; \
  elif apk info clang > /dev/null 2>&1; then \
    apk add --no-cache clang; \
    CLANG_BIN="clang"; \
    CXX_BIN="clang++"; \
    echo "Using system clang from Alpine repos"; \
  else \
    ARCH=$(uname -m) && \
    if [ "$ARCH" = "x86_64" ]; then \
      ARCH="amd64"; \
    fi && \
    CLANG_VERSION="19.1.7" && \
    CLANG_RELEASE_TAG="released-20251204-2252" && \
    CLANG_URL="https://github.com/lucrnz/software-distillery/releases/download/${CLANG_RELEASE_TAG}/testbuild_donotuseinproduction_clang-19-${CLANG_VERSION}-alpine-${ALPINE_VERSION}-${CLANG_RELEASE_TAG}-${ARCH}.tar.gz" && \
    mkdir -p /opt/clang19 && \
    cd /opt/clang19 && \
    ripvex --url="$CLANG_URL" --extract-archive --extract-strip-components=2 && \
    test -f env.sh && \
    ls -la /opt/clang19 && \
    echo "Using Clang-19 from Software Distillery GH Repo"; \
    . env.sh; \
    # The tarball provides versioned clang binaries, but lacks a clang++-19
    # wrapper; add a symlink so CXX=clang++-19 works during Node's configure.py
    if [ ! -x /opt/clang19/bin/clang++-19 ] && [ -x /opt/clang19/bin/clang ]; then \
      ln -sf /opt/clang19/bin/clang /opt/clang19/bin/clang++-19; \
    fi; \
    CLANG_BIN="/opt/clang19/bin/clang-19"; \
    CXX_BIN="/opt/clang19/bin/clang++-19"; \
    cd /root; \
  fi && \
  # Ensure clang can find standard C/C++ headers and libstdc++ headers
  GCC_VERSION=$(g++ -dumpversion) && \
  GCC_TARGET=$(g++ -dumpmachine) && \
  GCC_CPP_BASE="/usr/include/c++/${GCC_VERSION}" && \
  GCC_CPP_TARGET="${GCC_CPP_BASE}/${GCC_TARGET}" && \
  GCC_LIB="/usr/lib/gcc/${GCC_TARGET}/${GCC_VERSION}" && \
  CRTBEGIN_PATH=$(g++ -print-file-name=crtbeginS.o) && \
  CRTBEGIN_DIR=$(dirname "$CRTBEGIN_PATH") && \
  CPP_PATHS="${GCC_CPP_BASE}:${GCC_CPP_TARGET}" && \
  export CPLUS_INCLUDE_PATH="${CPP_PATHS}:${CPLUS_INCLUDE_PATH:-}" && \
  export C_INCLUDE_PATH="/usr/include:${C_INCLUDE_PATH:-}" && \
  # Make sure clang can locate GCC's crt objects (crtbeginS.o, etc.) and libs
  export LIBRARY_PATH="${CRTBEGIN_DIR}:${GCC_LIB}:${LIBRARY_PATH:-}" && \
  export LDFLAGS="-B${GCC_LIB} --gcc-toolchain=/usr -L${CRTBEGIN_DIR} -L${GCC_LIB} ${LDFLAGS:-}" && \
  # Force clang to target the detected GCC triple so ARM NEON types are available
  CLANG_TARGET="${GCC_TARGET}" && \
  export CC=${CC:-$CLANG_BIN} && \
  export CXX=${CXX:-$CXX_BIN} && \
  export CFLAGS="-B${GCC_LIB} --target=${CLANG_TARGET} --gcc-toolchain=/usr ${CFLAGS:-}" && \
  export CXXFLAGS="-B${GCC_LIB} --target=${CLANG_TARGET} --gcc-toolchain=/usr ${CXXFLAGS:-}" && \
  $CC --version && \
  . $PYENV_ROOT/env.sh && \
  . $NVM_DIR/nvm.sh && \
  echo "yarn@$YARN_VERSION" >> $NVM_DIR/default-packages && \
  nvm install $NODE_VERSION && \
  nvm alias default $NODE_VERSION && \
  nvm cache clear && \
  # smoke tests
  node -v && \
  npm -v && \
  yarn --version

# Final target image
FROM alpine:${ALPINE_VERSION} AS target
ENV NVM_DIR=/opt/nvm

RUN apk add --no-cache bash coreutils ca-certificates libstdc++ libffi \
  curl libbz2 zlib xz-libs ncurses-libs readline sqlite-libs gdbm expat libnsl

# NVM requires bash to work properly
SHELL ["/bin/bash", "-c"]

COPY --from=builder /opt/nvm /opt/nvm

RUN ln -sf $NVM_DIR/nvm.sh /etc/profile.d/nvm.sh

# Smoke test
RUN set -e && \
  . $NVM_DIR/nvm.sh && \
  node -v && \
  npm -v && \
  yarn --version

# Provide shell entrypoint
WORKDIR /root
ENTRYPOINT [ "/bin/bash", "-l" ]
